from django.utils import timezone

from rest_framework import serializers
from rest_framework.reverse import reverse as drf_reverse

from core.models import CustomUser as User
from .models import Article


class ArticleSerializer(serializers.ModelSerializer):
    """
    - Uses HyperlinkedIdentityField to expose a `url` for detail lookups (by slug).
    - Exposes `author` as a read‐only username, but accepts `author_id` on write.
    - Includes validation that when `is_published=True`, a `published_at` timestamp must be present.
    - Marks `slug`, `created_at`, `updated_at` as read‐only.
    - Provides `featured_image_url` (absolute URL) rather than raw file path.
    """

    # -------------------------
    # Read‐only / computed fields
    # -------------------------

    # 1. "url" field pointing to the detail endpoint (view name should match your URLconf).
    url = serializers.HyperlinkedIdentityField(
        view_name="article-detail",  # Adjust if your URLconf uses a different name/namespace
        lookup_field="slug",
        read_only=True,
    )

    # 2. Represent `author` as the username (read‐only).
    author = serializers.StringRelatedField(read_only=True)

    # 3. Expose a clickable absolute URL for the featured image.
    featured_image_url = serializers.SerializerMethodField(read_only=True)

    # 4. Slug is auto‐generated by the model; clients shouldn’t set it.
    slug = serializers.ReadOnlyField()

    # 5. created_at / updated_at are managed by the model; mark read‐only.
    created_at = serializers.DateTimeField(read_only=True)
    updated_at = serializers.DateTimeField(read_only=True)

    # 6. published_at is optional (can be null), but we enforce it in validate()
    published_at = serializers.DateTimeField(required=False, allow_null=True)

    # -------------------------
    # Write‐only / input‐specific fields
    # -------------------------

    # On writes, accept `author_id` (primary key) to associate an existing user.
    # Set required=False so we can catch missing author_id in validate().
    author_id = serializers.PrimaryKeyRelatedField(
        queryset=User.objects.all(),
        source="author",
        write_only=True,
        required=False,
        help_text="ID of the user who authored this article."
    )

    # -------------------------
    # Meta & field ordering
    # -------------------------
    class Meta:
        model = Article
        # Order fields so that “url” and identifiers appear first, then core content,
        # then metadata & timestamps.
        fields = [
            "url",             # read‐only detail link
            "id",              # primary key
            "slug",            # read‐only
            "author",          # read‐only username
            "author_id",       # write‐only
            "title",
            "excerpt",
            "content",
            "featured_image",       # allow file upload on create/update
            "featured_image_url",   # read‐only absolute URL
            "status",
            "is_published",
            "published_at",
            "created_at",
            "updated_at",
        ]

        read_only_fields = [
            "url",
            "id",
            "slug",
            "author",
            "featured_image_url",
            "created_at",
            "updated_at",
        ]

    # -------------------------
    # Field‐level / object‐level validation
    # -------------------------
    def validate(self, data):
        """
        1. If creating (self.instance is None) and no `author_id` was provided,
           raise ValidationError under key 'author'.

        2. Enforce that if `is_published` is True, then `published_at` must be provided.
           If the client didn’t supply `published_at`, but they set `is_published=True`,
           automatically set `published_at` now.
        """
        # 1) Check for missing author_id on creation
        if self.instance is None:
            if "author" not in data:
                raise serializers.ValidationError({"author": "This field is required."})

        # 2) Handle published_at auto‐population
        is_published = data.get("is_published", None)
        published_at = data.get("published_at", None)

        if is_published:
            if not published_at:
                data["published_at"] = timezone.now()

        return data

    # -------------------------
    # Serializer methods
    # -------------------------
    def get_featured_image_url(self, obj):
        """
        Return absolute URL for the `featured_image` if present;
        otherwise return None.
        """
        request = self.context.get("request")
        if obj.featured_image and obj.featured_image.url:
            return request.build_absolute_uri(obj.featured_image.url)
        return None

    # -------------------------
    # Overriding create/update
    # -------------------------
    def create(self, validated_data):
        """
        Make sure slug generation logic from the model still runs,
        and return the newly created Article.
        """
        article = Article.objects.create(**validated_data)
        return article

    def update(self, instance, validated_data):
        """
        Update only the fields provided. If `is_published` toggles from False → True
        and no `published_at` was present, our validate() already filled it in.
        """
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        return instance
