import math

from django.utils import timezone

from rest_framework import serializers
from rest_framework.reverse import reverse as drf_reverse

from core.models import CustomUser as User
from .models import Article, Video, ExerciseGuide, FitnessMeasurement



class ArticleSerializer(serializers.ModelSerializer):
    """
    - Uses HyperlinkedIdentityField to expose a `url` for detail lookups (by slug).
    - Exposes `author` as a read‐only username, but accepts `author_id` on write.
    - Includes validation that when `is_published=True`, a `published_at` timestamp must be present.
    - Marks `slug`, `created_at`, `updated_at` as read‐only.
    - Provides `featured_image_url` (absolute URL) rather than raw file path.
    """

    # -------------------------
    # Read‐only / computed fields
    # -------------------------

    # 1. "url" field pointing to the detail endpoint (view name should match your URLconf).
    url = serializers.HyperlinkedIdentityField(
        view_name="article-detail",  # Adjust if your URLconf uses a different name/namespace
        lookup_field="slug",
        read_only=True,
    )

    # 2. Represent `author` as the username (read‐only).
    author = serializers.StringRelatedField(read_only=True)

    # 3. Expose a clickable absolute URL for the featured image.
    featured_image_url = serializers.SerializerMethodField(read_only=True)

    # 4. Slug is auto‐generated by the model; clients shouldn’t set it.
    slug = serializers.ReadOnlyField()

    # 5. created_at / updated_at are managed by the model; mark read‐only.
    created_at = serializers.DateTimeField(read_only=True)
    updated_at = serializers.DateTimeField(read_only=True)

    # 6. published_at is optional (can be null), but we enforce it in validate()
    published_at = serializers.DateTimeField(required=False, allow_null=True)

    # -------------------------
    # Write‐only / input‐specific fields
    # -------------------------

    # On writes, accept `author_id` (primary key) to associate an existing user.
    # Set required=False so we can catch missing author_id in validate().
    author_id = serializers.PrimaryKeyRelatedField(
        queryset=User.objects.all(),
        source="author",
        write_only=True,
        required=False,
        help_text="ID of the user who authored this article."
    )

    # -------------------------
    # Meta & field ordering
    # -------------------------
    class Meta:
        model = Article
        # Order fields so that “url” and identifiers appear first, then core content,
        # then metadata & timestamps.
        fields = [
            "url",             # read‐only detail link
            "id",              # primary key
            "slug",            # read‐only
            "author",          # read‐only username
            "author_id",       # write‐only
            "title",
            "excerpt",
            "content",
            "featured_image",       # allow file upload on create/update
            "featured_image_url",   # read‐only absolute URL
            "status",
            "is_published",
            "published_at",
            "created_at",
            "updated_at",
        ]

        read_only_fields = [
            "url",
            "id",
            "slug",
            "author",
            "featured_image_url",
            "created_at",
            "updated_at",
        ]

    # -------------------------
    # Field‐level / object‐level validation
    # -------------------------
    def validate(self, data):
        """
        1. If creating (self.instance is None) and no `author_id` was provided,
           raise ValidationError under key 'author'.

        2. Enforce that if `is_published` is True, then `published_at` must be provided.
           If the client didn’t supply `published_at`, but they set `is_published=True`,
           automatically set `published_at` now.
        """
        # 1) Check for missing author_id on creation
        # if self.instance is None:
        #     if "author" not in data:
        #         raise serializers.ValidationError({"author": "This field is required."})

        # 2) Handle published_at auto‐population
        is_published = data.get("is_published", None)
        published_at = data.get("published_at", None)

        if is_published:
            if not published_at:
                data["published_at"] = timezone.now()

        return data

    # -------------------------
    # Serializer methods
    # -------------------------
    def get_featured_image_url(self, obj):
        """
        Return absolute URL for the `featured_image` if present;
        otherwise return None.
        """
        request = self.context.get("request")
        if obj.featured_image and obj.featured_image.url:
            return request.build_absolute_uri(obj.featured_image.url)
        return None

    # -------------------------
    # Overriding create/update
    # -------------------------
    def create(self, validated_data):
        """
        Make sure slug generation logic from the model still runs,
        and return the newly created Article.
        """
        article = Article.objects.create(**validated_data)
        return article

    def update(self, instance, validated_data):
        """
        Update only the fields provided. If `is_published` toggles from False → True
        and no `published_at` was present, our validate() already filled it in.
        """
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        return instance



class VideoSerializer(serializers.ModelSerializer):
    """
    - 'detail_url' is a HyperlinkedIdentityField for detail lookups by slug.
    - 'url' is the model’s URLField; clients supply this when creating/updating.
    - 'author' is read-only string; 'author_id' is write-only.
    - Validates that at least one of 'url' or 'embed_code' is present.
    - Auto-sets 'published_at' if 'is_published=True' and none provided.
    - 'slug', 'created_at', 'updated_at' are read-only.
    - 'thumbnail_url' returns an absolute URI if a thumbnail exists.
    """

    # 1) Hyperlinked identity for detail view (read-only)
    detail_url = serializers.HyperlinkedIdentityField(
        view_name="video-detail",
        lookup_field="slug",
        read_only=True,
    )

    # 2) Expose the model’s URLField as "url" in the API (writeable)
    url = serializers.URLField(
        required=False,
        allow_blank=True,
        help_text="External video link (e.g. YouTube/Vimeo URL).",
    )

    # 3) Represent 'author' as a string (username); read-only
    author = serializers.StringRelatedField(read_only=True)

    # 4) Absolute thumbnail URI
    thumbnail_url = serializers.SerializerMethodField(read_only=True)

    # 5) Slug is read-only
    slug = serializers.ReadOnlyField()

    # 6) created_at / updated_at are read-only
    created_at = serializers.DateTimeField(read_only=True)
    updated_at = serializers.DateTimeField(read_only=True)

    # 7) published_at is optional but auto-set when needed
    published_at = serializers.DateTimeField(required=False, allow_null=True)

    # 8) Write-only author_id for setting author FK
    author_id = serializers.PrimaryKeyRelatedField(
        queryset=User.objects.all(),
        source="author",
        write_only=True,
        help_text="ID of the user who created this video.",
    )

    class Meta:
        model = Video
        fields = [
            "detail_url",      # read-only link to /videos/{slug}/

            "id",
            "slug",

            "author",          # read-only
            "author_id",       # write-only

            "title",
            "description",
            "url",             # writeable model URL (external link)
            "embed_code",
            "thumbnail",       # allow upload
            "thumbnail_url",   # read-only absolute URI
            "duration",

            "status",
            "is_published",
            "published_at",

            "created_at",
            "updated_at",
        ]
        read_only_fields = [
            "detail_url",
            "id",
            "slug",
            "author",
            "thumbnail_url",
            "created_at",
            "updated_at",
        ]

    def validate(self, data):
        """
        - Ensure at least one of 'url' or 'embed_code' is present.
        - If 'is_published'=True and no 'published_at', set it to now.
        """
        model_url = (data.get("url") or "").strip()
        embed_code = (data.get("embed_code") or "").strip()
        is_published = data.get("is_published", None)
        published_at = data.get("published_at", None)

        if not model_url and not embed_code:
            raise serializers.ValidationError(
                {"url": ["Provide either a URL or embed code for the video."]}
            )

        if is_published and not published_at:
            data["published_at"] = timezone.now()

        return data

    def get_thumbnail_url(self, obj):
        """
        Return absolute URI for 'thumbnail' if present, else None.
        """
        request = self.context.get("request")
        if obj.thumbnail and hasattr(obj.thumbnail, "url"):
            return request.build_absolute_uri(obj.thumbnail.url)
        return None

    def create(self, validated_data):
        """
        Create a new Video. Model.save() will handle slug generation
        and setting published_at if needed.
        """
        return Video.objects.create(**validated_data)

    def update(self, instance, validated_data):
        """
        Update instance. If toggling from draft→published without 'published_at',
        set 'published_at' now.
        """
        was_published = instance.is_published
        new_is_published = validated_data.get("is_published", was_published)
        new_published_at = validated_data.get("published_at", instance.published_at)

        if not was_published and new_is_published and not new_published_at:
            validated_data["published_at"] = timezone.now()

        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        return instance



class ExerciseGuideSerializer(serializers.ModelSerializer):
    """
    - Exposes `url` (HyperlinkedIdentityField) for detail lookups by slug.
    - Shows `author` as read‐only string, accepts `author_id` on write.
    - Ensures `steps` is non‐empty.
    - Auto‐generates slug in model.save(); clients don’t set it.
    - Marks `slug`, `created_at`, `updated_at` as read‐only.
    - Provides `image_url` (absolute URL) rather than raw file path.
    """

    # 1) Hyperlinked identity for detail view (lookup on slug)
    url = serializers.HyperlinkedIdentityField(
        view_name="exerciseguide-detail",  # adjust to your router basename
        lookup_field="slug",
        read_only=True,
    )

    # 2) Represent the author as a string (username or __str__)
    author = serializers.StringRelatedField(read_only=True)

    # 3) Write‐only field to assign author by ID
    author_id = serializers.PrimaryKeyRelatedField(
        queryset=User.objects.all(),
        source="author",
        write_only=True,
        required=False,
        help_text="ID of the user who created this guide.",
    )

    # 4) Absolute URL for the image
    image_url = serializers.SerializerMethodField(read_only=True)

    # 5) Fields managed by the model: slug, timestamps
    slug = serializers.ReadOnlyField()
    created_at = serializers.DateTimeField(read_only=True)
    updated_at = serializers.DateTimeField(read_only=True)

    steps = serializers.CharField(
        required=True,
        allow_blank=True,
        help_text="Detailed, ordered steps (Markdown or HTML).",
    )

    class Meta:
        model = ExerciseGuide
        fields = [
            "url",
            "id",
            "slug",
            "author",
            "author_id",
            "name",
            "excerpt",
            "steps",
            "difficulty",
            "primary_muscle",
            "equipment_required",
            "image",
            "image_url",
            "video_embed",
            "created_at",
            "updated_at",
        ]
        read_only_fields = [
            "url",
            "id",
            "slug",
            "author",
            "image_url",
            "created_at",
            "updated_at",
        ]

    def validate(self, data):
        # 1) On create (instance is None) with an anonymous request, require author_id
        request = self.context.get("request", None)
        is_anon = not (request and getattr(request, "user", None) and request.user.is_authenticated)
        if self.instance is None and is_anon and "author" not in data:
            raise serializers.ValidationError({"author": "This field is required."})

        # 2) Ensure steps are present and non-blank
        steps = data.get("steps", None)
        if steps is not None and not steps.strip():
            raise serializers.ValidationError({"steps": "Exercise steps cannot be empty."})

        return data

    def get_image_url(self, obj):
        request = self.context.get("request")
        if obj.image and hasattr(obj.image, "url"):
            return request.build_absolute_uri(obj.image.url)
        return None

    def create(self, validated_data):
        # Slug auto-generated in model.save()
        guide = ExerciseGuide.objects.create(**validated_data)
        return guide

    def update(self, instance, validated_data):
        # Apply any changes; save() will regenerate slug only if blank
        for attr, val in validated_data.items():
            setattr(instance, attr, val)
        instance.save()
        return instance



class FitnessMeasurementSerializer(serializers.ModelSerializer):
        """
        - Exposes `url` (HyperlinkedIdentityField) for detail lookups by pk.
        - Represents `user` as read-only username, accepts `user_id` on write.
        - Validates positive height_cm & weight_kg, and date_of_birth in the past.
        - Exposes computed fields: height_m, bmi, bmi_category, bsa.
        - Marks `created_at` and `updated_at` read-only.
        """

        url = serializers.HyperlinkedIdentityField(
            view_name="fitnessmeasurement-detail",
            lookup_field="pk",
            read_only=True,
        )

        # user representation
        user = serializers.StringRelatedField(read_only=True)
        user_id = serializers.PrimaryKeyRelatedField(
            queryset=User.objects.all(),
            source="user",
            write_only=True,
            required=False, 
            help_text="ID of the user for this measurement",
        )

        # computed fields
        height_m = serializers.SerializerMethodField(read_only=True)
        bmi = serializers.SerializerMethodField(read_only=True)
        bmi_category = serializers.SerializerMethodField(read_only=True)
        bsa = serializers.SerializerMethodField(read_only=True)

        class Meta:
            model = FitnessMeasurement
            fields = [
                "url",
                "id",
                "user",
                "user_id",
                "height_cm",
                "weight_kg",
                "gender",
                "date_of_birth",
                "height_m",
                "bmi",
                "bmi_category",
                "bsa",
                "created_at",
                "updated_at",
            ]
            read_only_fields = [
                "url",
                "id",
                "user",
                "height_m",
                "bmi",
                "bmi_category",
                "bsa",
                "created_at",
                "updated_at",
            ]

        def validate_height_cm(self, value):
            if value <= 0:
                raise serializers.ValidationError("Height must be a positive integer.")
            return value

        def validate_weight_kg(self, value):
            if value <= 0:
                raise serializers.ValidationError("Weight must be a positive number.")
            return value

        def validate_date_of_birth(self, value):
            if value >= timezone.now().date():
                raise serializers.ValidationError("Date of birth must be in the past.")
            return value

        def get_height_m(self, obj):
            return obj.height_m

        def get_bmi(self, obj):
            return obj.bmi

        def get_bmi_category(self, obj):
            return obj.bmi_category

        def get_bsa(self, obj):
            return obj.bsa

        def create(self, validated_data):
            return super().create(validated_data)

        def update(self, instance, validated_data):
            return super().update(instance, validated_data)
